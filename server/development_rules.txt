Правила валидации и других аспектов разработки

1. Правила валидации данных

1.1. Разделение ответственности:
   - Валидация входных данных (формат, обязательные поля) выполняется в сериализаторах.
   - Бизнес-логика (проверка существования объектов, сложные условия) выполняется в сервисах.
   - Ограничения на уровне базы данных (например, max_length, уникальность) задаются в моделях.
   - Пример:
     # Сериализатор: Проверка, что текст не пустой
     if not attrs['text'].strip():
         raise InvalidCommentData("Текст комментария не может быть пустым.")
     # Сервис: Проверка существования отзыва
     review = Review.objects.get(pk=review_id)
     # Модель: Ограничение длины текста
     text = models.TextField(max_length=5000)

1.2. Проверка в сериализаторах:
   - Проверяйте формат данных, обязательные поля и ссылочную целостность (например, существование связанного объекта через PrimaryKeyRelatedField).
   - Добавляйте проверки для специфичных условий, связанных с API (например, активность продукта).
   - Пример:
     def validate_review(self, value):
         if not value.product.is_active:
             raise serializers.ValidationError("Комментарии к неактивным продуктам запрещены.")
         return value

1.3. Проверка в сервисах:
   - Выполняйте проверки, требующие доступа к базе данных или сложной бизнес-логики (например, проверка, что родительский комментарий относится к тому же отзыву).
   - Используйте кастомные исключения для информативных ошибок.
   - Пример:
     if parent.review_id != review.id:
         raise InvalidCommentData("Родительский комментарий должен относиться к тому же отзыву.")

1.4. Проверка в моделях:
   - Задавайте ограничения на уровне полей (например, max_length, null=False, unique).
   - Используйте метод clean() для кастомной валидации, связанной с внутренней структурой объекта.
   - Пример:
     def clean(self):
         if self.parent and self.parent.review != self.review:
             raise ValidationError("Родительский комментарий должен относиться к тому же отзыву.")

1.5. Избегайте дублирования:
   - Не повторяйте одну и ту же проверку в сериализаторе, сервисе и модели. Например, проверка на пустой текст должна быть только в сериализаторе.
   - Если проверка нужна в нескольких местах, выносите ее в утилитную функцию.
   - Пример:
     def is_valid_text(text: str) -> bool:
         return bool(text and text.strip())

1.6. Информативные ошибки:
   - Все ошибки валидации должны содержать понятное сообщение, объясняющее, что пошло не так.
   - Пример:
     raise InvalidCommentData("Текст комментария не может быть пустым или содержать только пробелы.")

2. Обработка ошибок

2.1. Использование кастомных исключений:
   - Создавайте кастомные исключения для каждой категории ошибок (например, CommentNotFound, InvalidCommentData).
   - Указывайте HTTP-статус и код ошибки.
   - Пример:
     class CommentNotFound(CommentException):
         status_code = 404
         default_detail = "Комментарий не найден"
         default_code = "not_found"

2.2. Централизованная обработка:
   - Используйте декораторы или middleware для обработки ошибок (например, handle_api_errors).
   - Возвращайте стандартизированные JSON-ответы с полями error и code.
   - Пример:
     return Response({"error": "Комментарий не найден", "code": "not_found"}, status=404)

2.3. Логирование ошибок:
   - Логируйте все ошибки с указанием пользователя, пути запроса и деталей.
   - Пример:
     logger.warning(f"Comment {comment_id} not found, user={user_id}, path={request.path}")

3. Логирование

3.1. Уровни логирования:
   - Используйте info для успешных операций, warning для некритичных ошибок, error для критических сбоев.
   - Пример:
     logger.info(f"Created Comment {comment.id}, user={user_id}")
     logger.error(f"Failed to create Comment: {str(e)}, user={user_id}")

3.2. Информативность:
   - Логи должны содержать идентификатор пользователя, идентификатор объекта (если применимо) и контекст действия.
   - Пример:
     logger.info(f"Retrieving comments for review={review_id}, user={user_id}")

4. Тестирование

4.1. Покрытие тестами:
   - Все публичные методы сервисов и API-эндпоинты должны быть покрыты юнит-тестами.
   - Проверяйте как успешные сценарии, так и обработку ошибок.
   - Пример:
     def test_create_comment_invalid_data(self):
         data = {"review": 1, "text": ""}
         with self.assertRaises(InvalidCommentData):
             CommentService.create_comment(data, self.user)

4.2. Тестирование валидации:
   - Проверяйте все случаи валидации (пустые данные, некорректные типы, несуществующие объекты).
   - Пример:
     def test_serializer_empty_text(self):
         serializer = CommentCreateSerializer(data={"review": 1, "text": ""})
         self.assertFalse(serializer.is_valid())
         self.assertIn("text", serializer.errors)

5. Общие рекомендации

5.1. Единообразие:
   - Следуйте единому стилю именования (camelCase для JavaScript, snake_case для Python).
   - Используйте одинаковые подходы для валидации и обработки ошибок во всех модулях.

5.2. Документация:
   - Каждый публичный метод или класс должен иметь docstring, соответствующий правилам из code_style_rules.txt.
   - Сложные участки кода должны быть прокомментированы.

5.3. Производительность:
   - Оптимизируйте запросы к базе данных, используя select_related и prefetch_related.
   - Избегайте лишних проверок валидации, если они уже выполнены на другом уровне.

5.4. Безопасность:
   - Проверяйте права доступа и активность пользователя перед выполнением операций.
   - Используйте rate limiting для защиты API от спама.